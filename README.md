Компилятор языка, описывающего операции над множествами. Кроме поддержки множеств имеются примитивы: String, Number и Boolean.
Множества задаются следующим шаблоном: ${a,b,test,1,2,{a,b,{1,3,2},c}}. Элементы множества отделяются запятыми и находятся 
внутри фигурных скобок. Описание множества начинается со знака $. Элементом множества может быть другое множество. Для этого перед 
именем переменной, которая должна быть элементом множества, ставится знак $.
Например: a = ${a,b}; b = ${a,b,$a,{$a}} <=> b = ${a,b,{a,b},{{a,b}}}.
Для множеств определены следующие операции: +(объединение), -(разность), *(пересечение), /(симметрическая разность).
При создании множества все его элементы сортируются определенным правилом и помещаются в SortedSet. Сортировка выполняется и для 
элементов подмножества. Так множества ${a,b,{a,b}} и ${b,{b,a},a} в итоге будут равны.

Имеется несколько основных интерфейсов:
  - Value (хранит значения примитивов и множеств (SetValue, StringValue, ...))
  - Expression (имеет метод Value eval(); является выражением, которое можно "посчитать")
  - Statement (имеет метод void execute(); является "выполнимой" частью программы; Statement может состоять из других Statement-ов,
    может содержать в себе Expression-ы)
  - Function (имеет метод Value execute(Value... args); нужен для описания и вызова пользовательских и системных функций)

Все переменный и функции хранятся в hashmap-ах в классах Variables и Functions, где ключом является имя переменной/функции, а значением
Value/Function соответственно.

Основной порядок действий:
 - задается путь к исходнику с программой.
 - содержимое исходной программы передается в класс Lexer, и вызывается метод tokenize(). В результате получится список токенов
   исходной программы. Токен состоит и типа токена, а также какой-то дополнительной информации (текст для типа WORD,
   множества для типа SET)
 - список токенов передается в класс Parser, и вызывается метод parse(). В результате получится опеределенный порядок Statement-ов.
   Далее вызывается метод execute() каждого объекта Statement.
 
 
